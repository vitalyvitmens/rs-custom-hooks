# React. 3. Пользовательские хуки



## Задача №1
### Действия по выполнению кода с пользовательским хуком useFetch и компонентом Task1:

#### Пользовательский хук useFetch принимает url и опции для запроса к API с помощью fetch. Он возвращает объект с данными, статусом загрузки, ошибкой, новыми опциями и функцией refetch.

#### Хук useFetch использует хук useLayoutEffect, чтобы выполнить запрос к API при изменении url или новых опций. Он также использует контроллер запроса, чтобы отменить предыдущий запрос, если он еще не завершен, или если компонент размонтирован.

#### Хук useFetch обрабатывает разные сценарии ответа от API: успешный, неуспешный или отмененный. Он сохраняет данные, статус загрузки и ошибку в соответствующие состояния с помощью хука useState.

#### Хук useFetch также предоставляет функцию refetch, которая позволяет обновить новые опции для запроса и вызвать хук useLayoutEffect снова, если нужно изменить параметры запроса и повторить запрос при нажатии на кнопку.

#### Компонент Task1 использует хук useFetch с url, который возвращает список posts. Он также использует хук useLayoutEffect, чтобы добавить новые опции к url при изменении их в хуке useFetch.

#### Компонент Task1 рендерит кнопку, которая вызывает функцию refetch с параметром _limit: 3. Это ограничивает количество posts = 3, которые возвращаются от API. Компонент также рендерит состояния загрузки и ошибки, а также список posts, если данные получены.



## Задача №2
### Действия по выполнению кода с пользовательским хуком useLocalStorage и компонентом Task2:

####  Создал пользовательский хук useLocalStorage, который позволяет сохранять и получать значение из localStorage в функциональных компонентах React.

####  Проверил, что localStorage доступен в браузере, используя функцию isLocalStorageAvailable, которая пытается записать и удалить тестовый ключ в localStorage и возвращает true или false в зависимости от результата. Если localStorage не доступен, ьросает ошибку с сообщением localStorage is not available.

####  Использовал хук useState для создания состояния value, которое хранит значение из localStorage по ключу storageKey. Передал функцию в качестве начального значения, которая пытается получить и распарсить значение из localStorage, или возвращает initialState, если значение не существует.

####  Создал объект methods, который содержит два метода для управления значением в localStorage: setItem и removeItem. Метод setItem принимает новое значение, обновляет состояние value и записывает новое значение в localStorage в формате JSON. Метод removeItem удаляет значение из состояния value и из localStorage по ключу storageKey.

####  Использовал хук useEffect для синхронизации значения в localStorage с другими вкладками браузера. Создал функцию handleStorageChange, которая принимает объект события, содержащий ключ, старое и новое значение, и обновляет состояние value в соответствии с новым значением, если ключ совпадает с storageKey. Добавил обработчик события storage при монтировании компонента, используя window.addEventListener, и удаляет его при размонтировании компонента, используя window.removeEventListener. Передал storageKey в качестве зависимости хука useEffect, чтобы он вызывался при изменении ключа.

####  Вернул массив с двумя элементами из хука useLocalStorage: value и methods. Это позволяет получить доступ к значению и методам для управления им при вызове хука в других компонентах.

####  Создал компонент Task2, который использует хук useLocalStorage с ключом token и начальным значением null. Деструктурировал массив, возвращенный хуком, на: token и { setItem, removeItem }. Переменная token содержит значение из localStorage, а объект { setItem, removeItem } содержит методы для управления значением.

####  Вернул JSX-разметку компонента Task2, которая отображает заголовок, параграф с токеном, и две кнопки для задания и удаления токена. Я использовал компонент Button из src\components\Button.jsx и стили из src\components\tasks.module.css. Добавил обработчики событий onClick для кнопок, которые вызывают методы setItem и removeItem с аргументами new-token и null соответственно.



## Задача №3
### Действия по выполнению кода с пользовательским хуком useHover и компонентом Task3:

####  Создал пользовательский хук useHover, который позволяет отслеживать наведение курсора на элемент, используя хуки useState, useRef и useEffect.

####  Создал состояние hovered, которое хранит булево значение, указывающее, наведен ли курсор на элемент или нет, использовал useState для инициализации состояния с начальным значением false.

####  Создал ссылку ref, которая будет присвоена элементу, на который нужно отслеживать наведение курсора, использовал useRef для создания ссылки с начальным значением null.

####  Создал две функции-обработчики событий: handleMouseEnter и handleMouseLeave. Эти функции будут вызываться, когда курсор входит и выходит из элемента, соответственно. Функция handleMouseEnter устанавливает состояние hovered в true, а функция handleMouseLeave устанавливает состояние hovered в false.

####  Использовал хук useEffect для добавления и удаления обработчиков событий mouseenter и mouseleave к элементу, на который ссылается ref. Для этого, в функции, переданной в useEffect, получил элемент из ref.current, проверил, что он существует, и добавил к нему обработчики событий с помощью addEventListener. Затем вернул из функции другую функцию, которая будет вызвана при размонтировании компонента, и которая удалит обработчики событий с помощью removeEventListener. Передал пустой массив в качестве второго аргумента useEffect, чтобы хук вызывался только при монтировании и размонтировании компонента.

####  Вернул из функции useHover объект с двумя свойствами: hovered и ref, это позволяет получить доступ к значению и ссылке при вызове хука в других компонентах.

####  Создал компонент Task3, который использует хук useHover с начальным значением null. Деструктурировал объект, возвращенный хуком, на две переменные: hovered и ref. Переменная hovered содержит значение из состояния, а переменная ref содержит ссылку на элемент.

####  Вернул JSX-разметку компонента Task3, которая отображает заголовок, элемент div, и текст внутри него. Присвоил ссылку ref элементу div и добавил класс styles.hoverable для стилизации элемента, также отобразил разный текст в зависимости от того, наведен ли курсор на элемент или нет, используя тернарный оператор.



## Задача №4
### Действия по выполнению кода с пользовательским хуком useViewportSize и компонентом Task4:

####  Создал пользовательский хук useViewportSize, который возвращает высоту и ширину окна браузера в пикселях.

####  Использовал хук useState для хранения и обновления значений высоты и ширины в состоянии компонента.

####  Использовал хук useCallback для создания функции resize, которая устанавливает высоту и ширину в соответствии с текущим размером окна.

####  Использовал пользовательский хук useWindowEvent, который добавляет и удаляет обработчик события resize для окна браузера с помощью хука useLayoutEffect.

####  Передал функцию resize и опцию passive в хук useWindowEvent, чтобы обеспечить плавное изменение размера окна без блокировки основного потока.

####  Создал компонент Task4, который рендерит два элемента с классами styles.width и styles.height, которые показывают текущую ширину и высоту окна в пикселях.

####  Использовал хук useViewportSize в компоненте Task4, чтобы получить значения высоты и ширины из хука useViewportSize.

####  Использовал хук useMemo для создания переменной view, которая возвращает JSX-разметку для элементов с классами styles.width и styles.height.

####  Передал значения высоты и ширины в массив зависимостей хука useMemo, чтобы избежать лишних рендеров при изменении размера окна.

####  Вернул элемент с заголовком Task4 и переменной view из компонента Task4.



## Дополнительная Задача №1
### Действия по выполнению кода с пользовательским хуком useWindowScroll и компонентом AdditionalTask1:

####  Реализовал пользовательский хук useWindowScroll, который позволяет получать и устанавливать позицию прокрутки окна браузера с помощью хуков useState, useCallback и useWindowEvent.

####  Использовал хук useWindowEvent для добавления и удаления слушателя события scroll на окно браузера с помощью хука useLayoutEffect, который обеспечивает более точное измерение позиции прокрутки и избегает проблем с асинхронностью.

####  Передал опцию passive в хук useWindowEvent, чтобы обеспечить плавную прокрутку без блокировки основного потока.

####  Реализовал компонент AdditionalTask1, который рендерит позицию прокрутки и кнопку для возврата к верху страницы с помощью компонента Button.

####  Использовал хук useWindowScroll в компоненте AdditionalTask1, чтобы получить позицию прокрутки и функцию scrollTo, которая устанавливает позицию прокрутки по заданным координатам.

####  Использовал хук useMemo для оптимизации производительности компонента AdditionalTask1, обернув JSX-разметку для позиции прокрутки в переменную view, которая пересчитывается только при изменении позиции прокрутки.

####  Стилизовал свой компонент AdditionalTask1, используя CSS-модули и классы, чтобы сделать его более красивым и удобным для пользователя.
